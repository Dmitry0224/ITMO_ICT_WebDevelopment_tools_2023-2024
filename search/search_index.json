{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\u041e\u0442\u0447\u0435\u0442 \u043f\u043e \u043b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u044b\u043c \u0440\u0430\u0431\u043e\u0442\u0430\u043c \u041b\u044f\u0434\u043e\u0432 \u0414\u043c\u0438\u0442\u0440\u0438\u0439","text":""},{"location":"lab1/configuration/","title":"\u0421\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430 \u043f\u0440\u043e\u0435\u043a\u0442\u0430","text":"<ul> <li><code>models</code> - \u043c\u043e\u0434\u0435\u043b\u0438</li> <li><code>endpoints</code> - \u0432\u0441\u0435 \u043c\u0435\u0442\u043e\u0434\u044b \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u043c\u043e\u0434\u0435\u043b\u044f\u043c\u0438</li> <li><code>main</code> - \u0444\u0430\u0439\u043b \u0437\u0430\u043f\u0443\u0441\u043a\u0430</li> <li><code>database</code> - \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0431\u0430\u0437\u044b \u0434\u0430\u043d\u043d\u044b\u0445</li> </ul>"},{"location":"lab1/endpoints/","title":"\u042d\u043d\u0434\u043f\u043e\u0439\u043d\u0442\u044b","text":"<p>\u042d\u043d\u0434\u043f\u043e\u0439\u043d\u0442\u044b \u0432 \u043c\u043e\u0435\u043c \u043f\u0440\u043e\u0435\u043a\u0442\u0435 \u0434\u0435\u043b\u044f\u0442\u0441\u044f \u043d\u0430</p> <ul> <li><code>auth_endpoints</code> - \u044d\u043d\u0434\u043f\u043e\u0439\u043d\u0442\u044b \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u0430\u0432\u0442\u043e\u0440\u0438\u0437\u0430\u0446\u0438\u0435\u0439</li> <li><code>user_endpoints</code> - \u044d\u043d\u0434\u043f\u043e\u0439\u043d\u0442\u044b \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\u043c\u0438</li> <li><code>book_endpoints</code> - \u044d\u043d\u0434\u043f\u043e\u0439\u043d\u0442\u044b \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u043a\u043d\u0438\u0433\u0430\u043c\u0438</li> <li><code>exchange_endpoint</code> - \u044d\u043d\u0434\u043f\u043e\u0439\u043d\u0442\u044b \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u0437\u0430\u043f\u0440\u043e\u0441\u0430\u043c\u0438 \u043d\u0430 \u043e\u0431\u043c\u0435\u043d</li> </ul>"},{"location":"lab1/endpoints/#auth_endpoints","title":"auth_endpoints","text":"<pre><code>from fastapi import APIRouter\nfrom auth import *\nfrom database import get_session\nfrom models import UserBase, User, UserShow, ChangePassword, UserCreate\nfrom sqlmodel import select\n\n\nauth_router = APIRouter()\n\n\n@auth_router.post('/registration', status_code=201, description='Register new user')\ndef register(user: UserCreate, session=Depends(get_session)):\n    users = session.exec(select(User)).all()\n    if any(x.username == user.username for x in users):\n        raise HTTPException(status_code=400, detail='Username is taken')\n    hashed_pwd = get_password_hash(user.password)\n    user = User(username=user.username, password=hashed_pwd)\n    session.add(user)\n    session.commit()\n    return {\"status\": 201, \"message\": \"Created\"}\n\n\n@auth_router.post('/login')\ndef login(user: UserCreate, session=Depends(get_session)):\n    user_found = session.exec(select(User).where(User.username == user.username)).first()\n    if not user_found:\n        raise HTTPException(status_code=401, detail='Invalid username and/or password')\n    verified = verify_password(user.password, user_found.password)\n    if not verified:\n        raise HTTPException(status_code=401, detail='Invalid username and/or password')\n    token = encode_token(user_found.username)\n    return {'token': token}\n\n\n@auth_router.get('/me', response_model=UserShow)\ndef get_current_user(user: User = Depends(get_current_user)) -&gt; User:\n    return user\n\n\n@auth_router.patch(\"/me/change-password\")\ndef user_pwd(user_pwd: ChangePassword, session=Depends(get_session), current=Depends(get_current_user)):\n    found_user = session.get(User, current.id)\n    if not found_user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    verified = verify_password(user_pwd.old_password, found_user.password)\n    if not verified:\n        raise HTTPException(status_code=400, detail=\"Invalid old password\")\n    hashed_pwd = get_password_hash(user_pwd.new_password)\n    found_user.password = hashed_pwd\n    session.add(found_user)\n    session.commit()\n    session.refresh(found_user)\n    return {\"status\": 200, \"message\": \"password changed successfully\"}\n\n</code></pre>"},{"location":"lab1/endpoints/#user_endpoints","title":"user_endpoints","text":"<pre><code>from fastapi import APIRouter\nfrom auth import *\nfrom database import get_session\nfrom models import UserBase, User, UserShow\nfrom sqlmodel import select\n\n\nuser_router = APIRouter()\n\n@user_router.get(\"/users/list\")\ndef user_list(session=Depends(get_session)) -&gt; list[User]:\n    users = session.exec(select(User)).all()\n    user_models = [user.model_dump(exclude={'password'}) for user in users]\n    return user_models\n\n\n@user_router.get(\"/users/{user_id}\")\ndef user_get(user_id: int, session=Depends(get_session)) -&gt; UserShow:\n    user = session.get(User, user_id)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user\n\n\n@user_router.delete(\"/users/delete/{travel_id}\")\ndef traveltogether_delete(user_id: int, session=Depends(get_session)):\n    user = session.get(User, user_id)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"user not found\")\n    session.delete(user)\n    session.commit()\n    return {\"ok\": True}\n\n</code></pre>"},{"location":"lab1/endpoints/#book_endpoints","title":"book_endpoints","text":"<pre><code>from fastapi import APIRouter, HTTPException, Depends\nfrom typing_extensions import TypedDict\nfrom models import BookCreate, Book, BookShow, User\nfrom database import get_session\nfrom auth import get_current_user\nbook_router = APIRouter()\n\n@book_router.post(\"/create\")\ndef create_book(book: BookCreate, user: User = Depends(get_current_user), session=Depends(get_session)) -&gt; TypedDict('Response', {\"status\": int, \"data\": Book}):\n    book_data = book.dict()\n    book_data[\"owner_id\"] = user.id\n    new_book = Book(**book_data)\n    session.add(new_book)\n    session.commit()\n    session.refresh(new_book)\n    return {\"status\": 200, \"data\": new_book}\n\n@book_router.get(\"/list\")\ndef list_books(session=Depends(get_session)) -&gt; list[BookShow]:\n    return session.query(Book).all()\n\n@book_router.get(\"/{book_id}\", response_model=BookShow)\ndef get_book(book_id: int, session=Depends(get_session)):\n    obj = session.get(Book, book_id)\n    if obj is None:\n        raise HTTPException(status_code=404, detail=\"Book not found\")\n    return obj\n\n@book_router.patch(\"/update/{book_id}\")\ndef update_book(book_id: int, book: BookCreate, session=Depends(get_session)) -&gt; Book:\n    db_book = session.get(Book, book_id)\n    if not db_book:\n        raise HTTPException(status_code=404, detail=\"Book not found\")\n\n    book_data = book.dict(exclude_unset=True)\n    for key, value in book_data.items():\n        setattr(db_book, key, value)\n    session.add(db_book)\n    session.commit()\n    session.refresh(db_book)\n    return db_book\n\n@book_router.delete(\"/delete/{book_id}\")\ndef delete_book(book_id: int, session=Depends(get_session)):\n    book = session.get(Book, book_id)\n    if not book:\n        raise HTTPException(status_code=404, detail=\"Book not found\")\n    session.delete(book)\n    session.commit()\n    return {\"ok\": True}\n\n</code></pre>"},{"location":"lab1/endpoints/#exchange_endpoint","title":"exchange_endpoint","text":"<pre><code>from fastapi import APIRouter, HTTPException, Depends\nfrom models import ExchangeRequestBase, ExchangeRequest, ExchangeRequestShow, User\nfrom database import get_session\nfrom typing_extensions import TypedDict\nfrom auth import get_current_user\n\nexchange_request_router = APIRouter()\n\n@exchange_request_router.post(\"/create/{book_id}\")\ndef exchange_request_create(\n    book_id: int,\n    exchange_request: ExchangeRequestBase,\n    current_user: User = Depends(get_current_user),\n    session=Depends(get_session)\n) -&gt; TypedDict('Response', {\"status\": int, \"data\": ExchangeRequest}):\n    exchange_request_data = exchange_request.dict()\n    exchange_request_data[\"book_id\"] = book_id\n    exchange_request_data[\"requester_id\"] = current_user.id\n\n    new_exchange_request = ExchangeRequest(**exchange_request_data)\n    session.add(new_exchange_request)\n    session.commit()\n    session.refresh(new_exchange_request)\n    return {\"status\": 200, \"data\": new_exchange_request}\n\n@exchange_request_router.get(\"/list\")\ndef exchange_request_list(session=Depends(get_session)) -&gt; list[ExchangeRequest]:\n    return session.query(ExchangeRequest).all()\n\n\n@exchange_request_router.get(\"/{request_id}\", response_model=ExchangeRequestShow)\ndef exchange_request_get(request_id: int, session=Depends(get_session)):\n    obj = session.get(ExchangeRequest, request_id)\n    if obj is None:\n        raise HTTPException(status_code=404, detail=\"Exchange request not found\")\n    return obj\n\n\n@exchange_request_router.patch(\"/update/{request_id}\")\ndef exchange_request_update(request_id: int, exchange_request: ExchangeRequestBase, session=Depends(get_session)) -&gt; ExchangeRequest:\n    db_request = session.get(ExchangeRequest, request_id)\n    if not db_request:\n        raise HTTPException(status_code=404, detail=\"Exchange request not found\")\n\n    request_data = exchange_request.model_dump(exclude_unset=True)\n    for key, value in request_data.items():\n        setattr(db_request, key, value)\n    session.add(db_request)\n    session.commit()\n    session.refresh(db_request)\n    return db_request\n\n\n@exchange_request_router.delete(\"/delete/{request_id}\")\ndef exchange_request_delete(request_id: int, session=Depends(get_session)):\n    exchange_request = session.get(ExchangeRequest, request_id)\n    if not exchange_request:\n        raise HTTPException(status_code=404, detail=\"Exchange request not found\")\n    session.delete(exchange_request)\n    session.commit()\n    return {\"ok\": True}\n\n</code></pre>"},{"location":"lab1/models/","title":"\u041c\u043e\u0434\u0435\u043b\u0438","text":"<p>\u041e\u0441\u043d\u043e\u0432\u043d\u044b\u0435 \u043c\u043e\u0434\u0435\u043b\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f:</p> <ul> <li><code>Book</code> - \u041a\u043d\u0438\u0433\u0430</li> <li><code>ExchangeRequest</code> - \u0417\u0430\u043f\u0440\u043e\u0441 \u043d\u0430 \u043e\u0431\u043c\u0435\u043d \u043a\u043d\u0438\u0433\u0438</li> <li><code>User</code> - \u041f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u0441\u0435\u0440\u0432\u0438\u0441\u0430</li> </ul>"},{"location":"lab1/models/#user","title":"User","text":"<pre><code>class UserBase(SQLModel):\n    username: str\n\nclass UserCreate(UserBase):\n    password: str\n\nclass UserShow(UserBase):\n    books: Optional[List[Book]] = None\n    exchange_requests: Optional[List[ExchangeRequest]] = None\n\nclass User(UserCreate, table=True):\n    id: int = Field(default=None, primary_key=True)\n    books: List[Book] = Relationship(back_populates=\"owner\")\n    exchange_requests: List[ExchangeRequest] = Relationship(back_populates=\"requester\")\n</code></pre>"},{"location":"lab1/models/#book","title":"Book","text":"<pre><code>\nclass BookStatus(Enum):\n    available = \"available\"\n    borrowed = \"borrowed\"\n    reserved = \"reserved\"\n\nclass BookBase(SQLModel):\n    title: str\n    author: str\n    description: str\n    is_available: bool\n\nclass BookCreate(BookBase):\n    pass\n\nclass BookShow(BookBase):\n    owner: Optional[\"UserBase\"] = None\n\nclass Book(BookBase, table=True):\n    id: int = Field(default=None, primary_key=True)\n    owner_id: Optional[int] = Field(default=None, foreign_key=\"user.id\")\n    owner: Optional[\"User\"] = Relationship(back_populates=\"books\")\n    exchange_requests: List[\"ExchangeRequest\"] = Relationship(back_populates=\"book\")\n\n</code></pre>"},{"location":"lab1/models/#exchangerequest","title":"ExchangeRequest","text":"<pre><code>class ExchangeRequestBase(SQLModel):\n    status: str\n    request_date: datetime.datetime\n    response_date: Optional[datetime.datetime] = None\n    message: str\n\nclass ExchangeRequestShow(ExchangeRequestBase):\n    requester: Optional[\"UserBase\"] = None\n    book: Optional[\"Book\"] = None\n\nclass ExchangeRequestCreate(BaseModel):\n    status: str\n    request_date: datetime.datetime\n    response_date: Optional[datetime.datetime] = None\n    message: str\n\n\nclass ExchangeRequest(ExchangeRequestBase, table=True):\n    id: int = Field(default=None, primary_key=True)\n    requester_id: int = Field(foreign_key=\"user.id\")\n    book_id: int = Field(foreign_key=\"book.id\")\n    requester: \"User\" = Relationship(back_populates=\"exchange_requests\")\n    book: \"Book\" = Relationship(back_populates=\"exchange_requests\")\n\n\n</code></pre>"},{"location":"lab1/routes/","title":"main.py","text":"<p>\u0412 \u0434\u0430\u043d\u043d\u043e\u043c \u0444\u0430\u0439\u043b\u0435 \u043d\u0430\u0445\u043e\u0434\u0438\u0442\u0441\u044f \u0440\u043e\u0443\u0442\u0435\u0440, \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u0435\u0442\u0441\u044f \u0431\u0430\u0437\u0430 \u0434\u0430\u043d\u043d\u044b\u0445 \u0438 \u0437\u0430\u043f\u0443\u0441\u043a\u0430\u0435\u0442\u0441\u044f \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435</p> <pre><code>from fastapi import FastAPI\nimport uvicorn\nfrom database import init_db\nfrom endpoints.user_endpoints import user_router\nfrom endpoints.book_endpoints import book_router\nfrom endpoints.exchange_endpoints import exchange_request_router\nfrom endpoints.auth_endpoints import auth_router\n\napp = FastAPI()\n\n\napp.include_router(auth_router, prefix=\"/api/auth\", tags=[\"auth\"])\napp.include_router(book_router, prefix=\"/api/books\", tags=[\"books\"])\napp.include_router(exchange_request_router, prefix=\"/api/exchange-requests\", tags=[\"exchange-requests\"])\napp.include_router(user_router, prefix=\"/api/users\", tags=[\"users\"])\n\n@app.on_event(\"startup\")\ndef on_startup():\n    init_db()\n\n\nif __name__ == '__main__':\n    uvicorn.run('main:app', host=\"localhost\", port=8000, reload=True)\n\n</code></pre>"},{"location":"lab2/task-1/","title":"Threads vs Porcess vs Async","text":"<p>\u0421\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0435 \u043f\u0435\u0440\u0444\u043e\u043c\u0430\u043d\u0441\u0430 3 \u043f\u043e\u0434\u0445\u043e\u0434\u043e\u0432 \u0432 python:</p> <ul> <li>multithread</li> <li>multiprocess</li> <li>async</li> </ul>"},{"location":"lab2/task-1/#_1","title":"\u041a\u043e\u0434 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b","text":"<pre><code>import asyncio\nimport threading\nimport multiprocessing\nimport time\n\n\ndef parts_thread_and_mult(s, e, res, idx):\n    res[idx] = sum(range(s, e + 1))\n\n\ndef sum_threading():\n    num_tasks = 4\n    n = 1000000\n    tasks_list = []\n    result = [0] * num_tasks\n    step = n // num_tasks\n\n    for i in range(num_tasks):\n        start = i * step + 1\n        end = (i + 1) * step if i != num_tasks - 1 else n\n        thread = threading.Thread(target=parts_thread_and_mult, args=(start, end, result, i))\n        tasks_list.append(thread)\n        thread.start()\n\n    for thread in tasks_list:\n        thread.join()\n\n    total = sum(result)\n    return total\n\n\n\ndef sum_multi():\n    num_tasks = 4\n    n = 1000000\n    tasks_list = []\n    step = n // num_tasks\n\n    manager = multiprocessing.Manager()\n    res = manager.list([0] * num_tasks)\n\n    for i in range(num_tasks):\n        s = i * step + 1\n        e = (i + 1) * step if i != num_tasks - 1 else n\n        process = multiprocessing.Process(target=parts_thread_and_mult, args=(s, e, res, i))\n        tasks_list.append(process)\n        process.start()\n\n    for process in tasks_list:\n        process.join()\n\n    _sum = sum(res)\n    return _sum\n\n\nasync def parts_async(s, e):\n    return sum(range(s, e + 1))\n\n\nasync def sum_async():\n    num_tasks = 4\n    n = 1000000\n    step = n // num_tasks\n    tasks = []\n\n    for i in range(num_tasks):\n        s = i * step + 1\n        e = (i + 1) * step if i != num_tasks - 1 else n\n        tasks.append(asyncio.create_task(parts_async(s, e)))\n\n    results = await asyncio.gather(*tasks)\n    total = sum(results)\n    return total\n\nif __name__ == '__main__':\n    start_time = time.time()\n    total = asyncio.run(sum_async())\n    end_time = time.time()\n    print(f\"Async time: {end_time - start_time} seconds\")\n\n    start_time = time.time()\n    total = sum_multi()\n    end_time = time.time()\n    print(f\"Multiprocessing time: {end_time - start_time} seconds\")\n\n\n    start_time = time.time()\n    total = sum_threading()\n    end_time = time.time()\n    print(f\"Threading time: {end_time - start_time} seconds\")\n</code></pre>"},{"location":"lab2/task-1/#_2","title":"\u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b","text":"<pre><code>Async time: 0.0416417121887207 seconds\nMultiprocessing time: 0.6034059524536133 seconds\nThreading time: 0.0812838077545166 seconds\n\n</code></pre>"},{"location":"lab2/task-1/#_3","title":"\u0412\u044b\u0432\u043e\u0434\u044b","text":"<p>\u0412 \u0434\u0430\u043d\u043d\u043e\u043c \u0437\u0430\u0434\u0430\u043d\u0438\u0438 \u043b\u0443\u0447\u0448\u0435 \u0432\u0441\u0435\u0433\u043e \u0441\u0435\u0431\u044f \u043f\u043e\u043a\u0430\u0437\u0430\u043b async, \u0447\u0443\u0442\u044c \u0445\u0443\u0436\u0435 multiprocessing, \u043d\u0443 \u0438 \u0445\u0443\u0436\u0435 \u0432\u0441\u0435\u0433\u043e threading, \u0442\u0430\u043a \u043a\u0430\u043a \u0437\u0430\u0442\u0440\u0430\u0447\u0438\u0432\u0430\u0435\u0442 \u0431\u043e\u043b\u044c\u0448\u0435 \u0432\u0441\u0435\u0433\u043e \u0440\u0435\u0441\u0443\u0440\u0441\u043e\u0432 \u043d\u0430 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043f\u043e\u0442\u043e\u043a\u043e\u0432</p>"},{"location":"lab2/task-2/","title":"\u041f\u0430\u0441\u0438\u043d\u0433 \u0432\u0435\u0431 \u0441\u0442\u0440\u0430\u043d\u0438\u0446","text":"<p>\u0422\u0443\u0442 \u044f \u043f\u0430\u0440\u0441\u0438\u043b \u0434\u0430\u043d\u043d\u044b\u0435 \u0441 \u0441\u0430\u0439\u0442\u0430 \u043a\u043d\u0438\u0436\u043d\u043e\u0433\u043e \u043c\u0430\u0433\u0430\u0437\u0438\u043d\u0430</p>"},{"location":"lab2/task-2/#_2","title":"\u041a\u043e\u0434 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b","text":"<pre><code>import asyncio\nimport aiohttp\nimport asyncpg\nimport multiprocessing\nimport threading\nimport psycopg2\nfrom bs4 import BeautifulSoup\nimport requests\nimport time\nfrom dotenv import load_dotenv\nimport os\nload_dotenv()\ndb_url = os.getenv(\"DB_URL\")\nfrom db import init_db\n\n\nasync def async_parse(session: aiohttp.ClientSession, url: str):\n    async with session.get(url) as response:\n        html = await response.text()\n        parsed_html = BeautifulSoup(html, \"html.parser\")\n        title = parsed_html.title.string\n\n        conn = await asyncpg.connect(os.getenv(\"DB_URL\"))\n        try:\n            await conn.execute(\n                \"INSERT INTO site (url, title, process_type) VALUES ($1, $2, $3)\",\n                url, title, 'async'\n            )\n        finally:\n            await conn.close()\n\n\nasync def async_main():\n    async with aiohttp.ClientSession() as session:\n        tasks = [async_parse(session, url) for url in urls]\n        await asyncio.gather(*tasks)\n\n\ndef mlp_parse(url):\n    response = requests.get(url)\n    soup = BeautifulSoup(response.content, 'html.parser')\n    title = soup.title.string if soup.title else 'No title'\n\n    conn = psycopg2.connect(os.getenv(\"DB_URL\"))\n    curs = conn.cursor()\n\n    curs.execute(\n        \"INSERT INTO site (url, title, process_type) VALUES (%s, %s, %s)\",\n        (url, title, 'multyprocess')\n    )\n\n    conn.commit()\n    curs.close()\n    conn.close()\n\n\ndef mlp_main():\n    processes = []\n    for url in urls:\n        process = multiprocessing.Process(target=mlp_parse, args=(url,))\n        processes.append(process)\n        process.start()\n\n    for process in processes:\n        process.join()\n\n\ndef thread_parse(url):\n    response = requests.get(url)\n    soup = BeautifulSoup(response.content, 'html.parser')\n    title = soup.title.string if soup.title else 'No title'\n\n    conn = psycopg2.connect(os.getenv(\"DB_URL\"))\n    curs = conn.cursor()\n\n    curs.execute(\n        \"INSERT INTO site (url, title, process_type) VALUES (%s, %s, %s)\",\n        (url, title, 'threading')\n    )\n    conn.commit()\n\n    curs.close()\n    conn.close()\n\n\ndef thread_main():\n    threads = []\n    for url in urls:\n        thread = threading.Thread(target=thread_parse, args=(url,))\n        threads.append(thread)\n        thread.start()\n\n    for thread in threads:\n        thread.join()\n\n\nif __name__ == \"__main__\":\n\n    urls = [\n    \"https://openlibrary.org/collections/dan-brown\",\n    \"https://openlibrary.org/collections/CYOA\",\n    \"https://openlibrary.org/collections/warhammer-40k-collection\",\n    \"https://openlibrary.org/collections/[A_Bible_Collection]\",\n    \"https://openlibrary.org/collections/star-wars\"\n    ]\n\n    asyncio.run(init_db())\n\n    start_time = time.time()\n    asyncio.run(async_main())\n    end_time = time.time()\n    print(f\"async time: {end_time - start_time}\\n\")\n\n    start_time = time.time()\n    mlp_main()\n    end_time = time.time()\n    print(f\"muliprocessing time: {end_time - start_time}\\n\")\n\n    start_time = time.time()\n    thread_main()\n    end_time = time.time()\n    print(f\"threading time: {end_time - start_time}\\n\")\n</code></pre>"},{"location":"lab2/task-2/#_3","title":"\u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b \u0437\u0430\u043c\u0435\u0440\u043e\u0432","text":"<pre><code>async time: 1.5550189018249512\n\nmuliprocess time: 3.908064126968384\n\nthread time: 2.224595785140991\n\n</code></pre> <p>\u041f\u043e \u0438\u0442\u043e\u0433\u0443 \u0432 \u0437\u0430\u0434\u0430\u0447\u0435 \u0432\u0432\u043e\u0434\u0430-\u0432\u044b\u0432\u043e\u0434\u0430 \u043b\u0443\u0447\u0448\u0435 \u0432\u0441\u0435\u0433\u043e \u0441\u0435\u0431\u044f \u043f\u043e\u043a\u0430\u0437\u0430\u043b async, \u0447\u0443\u0442\u044c \u0445\u0443\u0436\u0435 \u0441\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442\u0441\u044f threading \u0438 \u0445\u0443\u0436\u0435 \u0432\u0441\u0435\u0433\u043e muliprocessing</p>"},{"location":"lab3/celery/","title":"\u0421\u0435\u0440\u0432\u0438\u0441 \u043f\u0430\u0440\u0441\u0438\u043d\u0433\u0430","text":""},{"location":"lab3/celery/#celery-function","title":"celery function","text":"<pre><code>import threading\nimport requests\nfrom bs4 import BeautifulSoup\nimport time\nfrom db import Parce\nfrom celery import Celery\n\ncelery_app = Celery(\n    \"worker\",\n    broker=\"redis://redis:6379/0\",\n    backend=\"redis://redis:6379/0\",\n)\n\ncelery_app.conf.update(\n    task_routes={\n        \"parse.parse_and_save\": \"main-queue\",\n    },\n)\n\n\n@celery_app.task\ndef parse_and_save(url,  session):\n    response = requests.get(url)\n    soup = BeautifulSoup(response.content, 'html.parser')\n    title = soup.title.string if soup.title else 'No title'\n\n    new_article = Parce(\n        url = url,\n        article_title = title\n    )\n\n    session.add(new_article)\n    session.commit()\n\n</code></pre>"},{"location":"lab3/docker/","title":"\u0414\u043e\u043a\u0435\u0440","text":"<pre><code>FROM python:3.9.19-alpine3.20\n\nWORKDIR ./books_app\n\nCOPY . .\nRUN pip3 install -r requirements.txt\n\nCMD uvicorn main:app --host localhost --port 8000\n</code></pre> <pre><code>services:\n  lab_3_bd:\n    container_name: lab_3_bd\n    image: postgres\n    restart: always\n    environment:\n      - POSTGRES_PASSWORD=1122\n      - POSTGRES_USER=postgres\n      - POSTGRES_DB=web_data\n      - POSTGRES_PORT=5432\n    volumes:\n      - postgres_data:/var/lib/postgresql/data/\n    ports:\n      - \"5432:5432\"\n    networks:\n      - backend\n\n  books_app:\n    container_name: books_app\n    build:\n      context: ./books_app\n    env_file: .env\n    depends_on:\n      - lab_3_bd\n    ports:\n      - \"8000:8000\"\n    command: uvicorn main:app --host 0.0.0.0 --port 8000\n    networks:\n      - backend\n    restart: always\n\n  parse_app:\n    container_name: parse_app\n    build:\n      context: ./parse_app\n    env_file: .env\n    depends_on:\n      - lab_3_bd\n    ports:\n      - \"2000:2000\"\n    command: uvicorn main:app --host 0.0.0.0 --port 2000\n    networks:\n      - backend\n    restart: always\n    dns:\n      - 8.8.8.8\n      - 8.8.4.4\n\n  celery:\n    build:\n      context: ./parse_app\n    container_name: celery\n    command: celery -A celery_run worker --loglevel=info\n    restart: always\n    depends_on:\n      - redis\n      - lab_3_bd\n    networks:\n      - backend\n\n  redis:\n    image: redis\n    ports:\n      - \"6379:6379\"\n    networks:\n      - backend\n\nvolumes:\n  postgres_data:\n\nnetworks:\n  backend:\n    driver: bridge\n</code></pre>"}]}